#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Vue d'authentification moderne pour l'application Vynal Docs Automator
"""

import os
import json
import logging
import hashlib
import customtkinter as ctk
from typing import Callable, Optional, Dict, Any
from utils.usage_tracker import UsageTracker
from datetime import datetime
import tkinter as tk
from PIL import Image
import time

logger = logging.getLogger("VynalDocsAutomator.AuthView")

class AuthView:
    """Vue moderne pour l'authentification et la gestion de compte"""
    
    # Constantes pour la validation
    PASSWORD_MIN_LENGTH = 8
    MAX_LOGIN_ATTEMPTS = 5
    LOGIN_TIMEOUT = 300  # 5 minutes
    
    def __init__(self, parent, usage_tracker=None):
        """
        Initialise la vue d'authentification
        
        Args:
            parent: Widget parent
            usage_tracker: Instance du gestionnaire d'utilisation
        """
        self.parent = parent
        self.usage_tracker = usage_tracker or UsageTracker()
        
        # √âtat de connexion et s√©curit√©
        self.current_user = None
        self.on_auth_change_callback = None
        self.login_attempts = {}  # {email: [timestamp, count]}
        
        # Variables de validation
        self.email_valid = False
        self.password_valid = False
        self.confirm_password_valid = False
        
        # Variables
        self.current_tab = ctk.StringVar(value="login")
        self.email_var = ctk.StringVar()
        self.password_var = ctk.StringVar()
        self.confirm_password_var = ctk.StringVar()
        self.register_name_var = ctk.StringVar()
        
        # Stockage des r√©f√©rences aux widgets
        self.main_frame = None
        self.window = None
        self.login_frame = None
        self.register_frame = None
        self.account_frame = None
        self.login_tab = None
        self.register_tab = None
        self.account_tab = None
        
        # Tracer les changements des variables
        self.email_var.trace_add("write", self._validate_email)
        self.password_var.trace_add("write", self._validate_password)
        self.confirm_password_var.trace_add("write", self._validate_confirm_password)
        
        # R√©f√©rence aux onglets
        self.tabs = None
        
        # Ne pas cr√©er les widgets imm√©diatement, attendre l'appel √† show()
    
    def _create_widgets(self):
        """Cr√©e les widgets de l'interface"""
        try:
            # Frame principal avec padding
            self.main_frame = ctk.CTkFrame(self.window)
            self.main_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
            
            # En-t√™te avec logo/ic√¥ne
            self._create_header()
            
            # Onglets de navigation
            self._create_tabs()
            
            # Frame de contenu
            self.content_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
            self.content_frame.pack(fill=ctk.BOTH, expand=True, padx=10, pady=10)
            
            # Cr√©er les diff√©rentes vues
            self._create_login_view()
            self._create_register_view()
            self._create_account_view()
            
            # Mettre √† jour l'affichage selon l'onglet courant
            tab_name = self.current_tab.get()
            self._update_tab_content()
            
            logger.info("Widgets de l'interface d'authentification cr√©√©s")
        except Exception as e:
            logger.error(f"Erreur lors de la cr√©ation des widgets de l'interface: {e}")
            # Tenter une approche plus simple en cas d'√©chec
            try:
                # Frame principal
                self.main_frame = ctk.CTkFrame(self.window)
                self.main_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
                
                # Titre simple
                ctk.CTkLabel(
                    self.main_frame,
                    text="Connexion √† l'application",
                    font=ctk.CTkFont(size=16, weight="bold")
                ).pack(pady=10)
                
                # Cr√©er juste la vue de connexion
                self.login_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
                self.login_frame.pack(fill=ctk.BOTH, expand=True, padx=10, pady=10)
                
                # Champs de connexion
                ctk.CTkLabel(self.login_frame, text="Email:").pack(anchor="w", pady=(10, 0))
                self.email_var = ctk.StringVar()
                ctk.CTkEntry(
                    self.login_frame,
                    textvariable=self.email_var,
                    width=250
                ).pack(pady=(0, 10))
                
                ctk.CTkLabel(self.login_frame, text="Mot de passe:").pack(anchor="w", pady=(10, 0))
                self.password_var = ctk.StringVar()
                ctk.CTkEntry(
                    self.login_frame,
                    textvariable=self.password_var,
                    show="‚Ä¢",
                    width=250
                ).pack(pady=(0, 10))
                
                # Bouton de connexion
                ctk.CTkButton(
                    self.login_frame,
                    text="Se connecter",
                    command=self._handle_login,
                    width=250
                ).pack(pady=20)
                
                # Message d'erreur
                self.login_status_label = ctk.CTkLabel(
                    self.login_frame,
                    text="",
                    text_color="red"
                )
                self.login_status_label.pack(pady=5)
                
                logger.info("Interface d'authentification simplifi√©e cr√©√©e")
            except Exception as e2:
                logger.critical(f"√âchec critique lors de la cr√©ation d'une interface de secours: {e2}")
    
    def _create_header(self):
        """Cr√©e l'en-t√™te avec logo"""
        header = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        header.pack(fill=ctk.X, pady=(0, 20))
        
        # Logo/Ic√¥ne
        logo_label = ctk.CTkLabel(
            header,
            text="üë§",  # Emoji comme ic√¥ne
            font=ctk.CTkFont(size=48)
        )
        logo_label.pack(pady=(0, 10))
        
        # Titre
        title_label = ctk.CTkLabel(
            header,
            text="Bienvenue",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title_label.pack()
    
    def _create_tabs(self):
        """Cr√©e les onglets de navigation"""
        try:
            # Cr√©er le frame des onglets
            self.tabs = ctk.CTkFrame(self.main_frame, fg_color="transparent")
            self.tabs.pack(fill=ctk.X, padx=10, pady=(10, 0))
            
            # Styles des onglets
            tab_height = 30
            tab_width = 120
            tab_corner_radius = 8
            
            # Cr√©er les onglets
            # Onglet Connexion
            self.login_tab = ctk.CTkButton(
                self.tabs,
                text="Connexion",
                height=tab_height,
                width=tab_width,
                corner_radius=tab_corner_radius,
                fg_color="transparent",
                text_color=("gray10", "gray90"),
                hover_color=("gray85", "gray25"),
                command=lambda: self._show_tab("login")
            )
            self.login_tab.pack(side=ctk.LEFT, padx=5, pady=0)
            
            # Onglet Inscription
            self.register_tab = ctk.CTkButton(
                self.tabs,
                text="Inscription",
                height=tab_height,
                width=tab_width,
                corner_radius=tab_corner_radius,
                fg_color="transparent",
                text_color=("gray10", "gray90"),
                hover_color=("gray85", "gray25"),
                command=lambda: self._show_tab("register")
            )
            self.register_tab.pack(side=ctk.LEFT, padx=5, pady=0)
            
            # Onglet Compte (visible uniquement si connect√©)
            self.account_tab = ctk.CTkButton(
                self.tabs,
                text="Compte",
                height=tab_height,
                width=tab_width,
                corner_radius=tab_corner_radius,
                fg_color="transparent",
                text_color=("gray10", "gray90"),
                hover_color=("gray85", "gray25"),
                command=lambda: self._show_tab("account")
            )
            self.account_tab.pack(side=ctk.LEFT, padx=5, pady=0)
            
            # S√©parateur horizontal sous les onglets
            ctk.CTkFrame(self.main_frame, height=1, fg_color="gray").pack(fill=ctk.X, padx=10, pady=(0, 0))
            
            # Mettre en √©vidence l'onglet actuel
            tab_name = self.current_tab.get()
            if tab_name == "login":
                self.login_tab.configure(fg_color=("gray85", "gray25"))
            elif tab_name == "register":
                self.register_tab.configure(fg_color=("gray85", "gray25"))
            elif tab_name == "account":
                self.account_tab.configure(fg_color=("gray85", "gray25"))
                
            logger.debug("Onglets cr√©√©s avec succ√®s")
        except Exception as e:
            logger.error(f"Erreur lors de la cr√©ation des onglets: {e}")
            # Cr√©er une version simplifi√©e des onglets avec une gestion d'erreur plus robuste
            try:
                # Si le frame des onglets existe d√©j√†, le nettoyer
                if hasattr(self, 'tabs') and self.tabs:
                    for widget in self.tabs.winfo_children():
                        widget.destroy()
                else:
                    # Sinon cr√©er un nouveau frame
                    self.tabs = ctk.CTkFrame(self.main_frame, fg_color="transparent")
                    self.tabs.pack(fill=ctk.X, padx=10, pady=(10, 0))
                
                # Cr√©er les onglets basiques
                tabs_info = [
                    {"name": "login", "text": "Connexion"},
                    {"name": "register", "text": "Inscription"},
                    {"name": "account", "text": "Compte"}
                ]
                
                # Cr√©er chaque onglet individuellement
                for tab in tabs_info:
                    btn = ctk.CTkButton(
                        self.tabs,
                        text=tab["text"],
                        height=30,
                        width=120,
                        corner_radius=8,
                        fg_color="transparent",
                        text_color=("gray10", "gray90"),
                        hover_color=("gray85", "gray25"),
                        command=lambda t=tab["name"]: self._show_tab(t)
                    )
                    btn.pack(side=ctk.LEFT, padx=5, pady=0)
                    
                    # Garder une r√©f√©rence aux onglets
                    setattr(self, f"{tab['name']}_tab", btn)
                
                # S√©parateur
                ctk.CTkFrame(self.main_frame, height=1, fg_color="gray").pack(fill=ctk.X, padx=10, pady=(0, 0))
                
                logger.debug("Version simplifi√©e des onglets cr√©√©e apr√®s erreur")
            except Exception as e2:
                logger.error(f"√âchec critique lors de la cr√©ation des onglets alternatifs: {e2}")
                # Derni√®re tentative ultra simplifi√©e
                self.tabs = ctk.CTkFrame(self.main_frame, fg_color="transparent")
                self.tabs.pack(fill=ctk.X, padx=10, pady=(10, 0))
                
                # Juste un titre pour indiquer l'onglet actuel
                tab_name = self.current_tab.get().capitalize()
                ctk.CTkLabel(
                    self.tabs,
                    text=f"Vue: {tab_name}",
                    font=ctk.CTkFont(size=14, weight="bold")
                ).pack(pady=5)
    
    def _create_login_view(self):
        """Cr√©e la vue de connexion"""
        self.login_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        
        # Titre
        ctk.CTkLabel(
            self.login_frame,
            text="Connexion √† votre compte",
            font=ctk.CTkFont(size=20, weight="bold")
        ).pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        # Cadre du formulaire
        form_frame = ctk.CTkFrame(self.login_frame, fg_color="transparent")
        form_frame.pack(fill=ctk.X, padx=20)
        
        # Champ email
        email_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        email_frame.pack(fill=ctk.X, pady=(0, 15))
        
        ctk.CTkLabel(
            email_frame,
            text="Adresse email",
            anchor="w"
        ).pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        self.login_email = ctk.CTkEntry(
            email_frame,
            textvariable=self.email_var,
            placeholder_text="Votre adresse email",
            height=40,
            border_width=1
        )
        self.login_email.pack(fill=ctk.X)
        
        # Message d'erreur email
        self.login_email_error = ctk.CTkLabel(
            email_frame,
            text="",
            text_color="red",
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.login_email_error.pack(fill=ctk.X, padx=5)
        
        # Champ mot de passe
        password_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        password_frame.pack(fill=ctk.X, pady=(0, 10))
        
        # Libell√© et lien "Mot de passe oubli√©"
        pwd_header = ctk.CTkFrame(password_frame, fg_color="transparent")
        pwd_header.pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        ctk.CTkLabel(
            pwd_header,
            text="Mot de passe",
            anchor="w"
        ).pack(side=ctk.LEFT)
        
        # Champ de saisie du mot de passe
        self.login_password = ctk.CTkEntry(
            password_frame,
            textvariable=self.password_var,
            placeholder_text="Votre mot de passe",
            show="‚Ä¢",
            height=40,
            border_width=1
        )
        self.login_password.pack(fill=ctk.X)
        
        # Message d'erreur mot de passe
        self.login_password_error = ctk.CTkLabel(
            password_frame,
            text="",
            text_color="red",
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.login_password_error.pack(fill=ctk.X, padx=5)
        
        # Option "Se souvenir de moi"
        self.remember_var = ctk.BooleanVar(value=False)
        remember_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        remember_frame.pack(fill=ctk.X, pady=(0, 20))
        
        remember_checkbox = ctk.CTkCheckBox(
            remember_frame,
            text="Se souvenir de moi",
            variable=self.remember_var,
            border_width=2,
            corner_radius=6,
            hover_color=("#3498db", "#2980b9"),
            fg_color=("#3498db", "#2980b9")
        )
        remember_checkbox.pack(side=ctk.LEFT, padx=5)
        
        # Message de statut pour la connexion
        self.login_status_label = ctk.CTkLabel(
            form_frame,
            text="",
            text_color="red",
            anchor="center",
            font=ctk.CTkFont(size=12)
        )
        self.login_status_label.pack(fill=ctk.X, padx=5, pady=(0, 10))
        
        # Bouton de connexion
        self.login_button = ctk.CTkButton(
            form_frame,
            text="Se connecter",
            command=self._handle_login,
            height=40,
            corner_radius=8,
            fg_color=("#3498db", "#2980b9"),
            hover_color=("#2980b9", "#1f618d")
        )
        self.login_button.pack(fill=ctk.X, pady=(0, 20))
        
        # Pas de s√©parateur pour simplifier
        # self._create_separator(form_frame)
        
        # Lien vers l'inscription
        register_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        register_frame.pack(fill=ctk.X, pady=(10, 0))
        
        ctk.CTkLabel(
            register_frame,
            text="Vous n'avez pas de compte ?",
            anchor="center"
        ).pack(pady=(0, 5))
        
        register_link = ctk.CTkButton(
            register_frame,
            text="Cr√©er un compte",
            font=ctk.CTkFont(size=13, underline=True),
            fg_color="transparent",
            hover_color="transparent",
            text_color=("#3498db", "#2980b9"),
            width=30,
            height=20,
            command=lambda: self._show_tab("register")
        )
        register_link.pack()
    
    def _create_separator(self, parent):
        """
        Cr√©e un s√©parateur avec le texte 'ou'
        
        Args:
            parent: Widget parent
        """
        separator_frame = ctk.CTkFrame(parent, fg_color="transparent")
        separator_frame.pack(fill=ctk.X, pady=10)
        
        # Ligne gauche
        left_line = ctk.CTkFrame(separator_frame, height=1, fg_color="gray")
        left_line.pack(side=ctk.LEFT, fill=ctk.X, expand=True, padx=(0, 10))
        
        # Texte "ou"
        ctk.CTkLabel(
            separator_frame,
            text="ou",
            text_color="gray",
            font=ctk.CTkFont(size=12)
        ).pack(side=ctk.LEFT)
        
        # Ligne droite
        right_line = ctk.CTkFrame(separator_frame, height=1, fg_color="gray")
        right_line.pack(side=ctk.RIGHT, fill=ctk.X, expand=True, padx=(10, 0))
    
    def _create_register_view(self):
        """Cr√©e la vue d'inscription"""
        self.register_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        
        # Titre
        ctk.CTkLabel(
            self.register_frame,
            text="Cr√©er un compte",
            font=ctk.CTkFont(size=20, weight="bold")
        ).pack(pady=(0, 20))
        
        # Cadre du formulaire
        form_frame = ctk.CTkFrame(self.register_frame, fg_color="transparent")
        form_frame.pack(fill=ctk.X, padx=20)
        
        # Champ nom
        name_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        name_frame.pack(fill=ctk.X, pady=(0, 15))
        
        ctk.CTkLabel(
            name_frame,
            text="Nom complet",
            anchor="w"
        ).pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        self.name_var = ctk.StringVar()
        self.register_name = ctk.CTkEntry(
            name_frame,
            textvariable=self.name_var,
            placeholder_text="Votre nom complet",
            height=40,
            border_width=1
        )
        self.register_name.pack(fill=ctk.X)
        
        # Message d'erreur nom
        self.register_name_error = ctk.CTkLabel(
            name_frame,
            text="",
            text_color="red",
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.register_name_error.pack(fill=ctk.X, padx=5)
        
        # Champ email
        email_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        email_frame.pack(fill=ctk.X, pady=(0, 15))
        
        ctk.CTkLabel(
            email_frame,
            text="Adresse email",
            anchor="w"
        ).pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        self.register_email = ctk.CTkEntry(
            email_frame,
            textvariable=self.email_var,
            placeholder_text="Votre adresse email",
            height=40,
            border_width=1
        )
        self.register_email.pack(fill=ctk.X)
        
        # Message d'erreur email
        self.register_email_error = ctk.CTkLabel(
            email_frame,
            text="",
            text_color="red",
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.register_email_error.pack(fill=ctk.X, padx=5)
        
        # Champ mot de passe
        password_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        password_frame.pack(fill=ctk.X, pady=(0, 15))
        
        ctk.CTkLabel(
            password_frame,
            text="Mot de passe",
            anchor="w"
        ).pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        self.register_password = ctk.CTkEntry(
            password_frame,
            textvariable=self.password_var,
            placeholder_text="Cr√©ez un mot de passe s√©curis√©",
            show="‚Ä¢",
            height=40,
            border_width=1
        )
        self.register_password.pack(fill=ctk.X)
        
        # Message d'erreur mot de passe
        self.register_password_error = ctk.CTkLabel(
            password_frame,
            text="",
            text_color="red",
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.register_password_error.pack(fill=ctk.X, padx=5)
        
        # Indicateur de force du mot de passe
        self.password_strength_frame = ctk.CTkFrame(password_frame, fg_color="transparent")
        self.password_strength_frame.pack(fill=ctk.X, padx=5, pady=(5, 0))
        
        self.password_strength_indicator = ctk.CTkProgressBar(
            self.password_strength_frame,
            width=200,
            height=8,
            corner_radius=2,
            mode="determinate"
        )
        self.password_strength_indicator.pack(side=ctk.LEFT, fill=ctk.X, expand=True)
        self.password_strength_indicator.set(0)
        
        self.password_strength_label = ctk.CTkLabel(
            self.password_strength_frame,
            text="Faible",
            font=ctk.CTkFont(size=12),
            text_color="gray"
        )
        self.password_strength_label.pack(side=ctk.RIGHT, padx=(10, 0))
        
        # Champ confirmation de mot de passe
        confirm_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        confirm_frame.pack(fill=ctk.X, pady=(0, 15))
        
        ctk.CTkLabel(
            confirm_frame,
            text="Confirmer le mot de passe",
            anchor="w"
        ).pack(fill=ctk.X, padx=5, pady=(0, 5))
        
        self.register_confirm = ctk.CTkEntry(
            confirm_frame,
            textvariable=self.confirm_password_var,
            placeholder_text="Confirmez votre mot de passe",
            show="‚Ä¢",
            height=40,
            border_width=1
        )
        self.register_confirm.pack(fill=ctk.X)
        
        # Message d'erreur confirmation
        self.register_confirm_error = ctk.CTkLabel(
            confirm_frame,
            text="",
            text_color="red",
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.register_confirm_error.pack(fill=ctk.X, padx=5)
        
        # Conditions d'utilisation
        terms_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        terms_frame.pack(fill=ctk.X, pady=(0, 20))
        
        self.terms_var = ctk.BooleanVar(value=False)
        terms_checkbox = ctk.CTkCheckBox(
            terms_frame,
            text="J'accepte les ",
            variable=self.terms_var,
            border_width=2,
            corner_radius=6,
            hover_color=("#3498db", "#2980b9"),
            fg_color=("#3498db", "#2980b9")
        )
        terms_checkbox.pack(side=ctk.LEFT, padx=5)
        
        terms_link = ctk.CTkButton(
            terms_frame,
            text="conditions d'utilisation",
            font=ctk.CTkFont(size=13, underline=True),
            fg_color="transparent",
            hover_color="transparent",
            text_color=("#3498db", "#2980b9"),
            width=30,
            height=20,
            command=self._show_terms
        )
        terms_link.pack(side=ctk.LEFT, padx=0)
        
        # Bouton d'inscription
        self.register_button = ctk.CTkButton(
            form_frame,
            text="Cr√©er mon compte",
            command=self._handle_register,
            height=40,
            corner_radius=8,
            fg_color=("#3498db", "#2980b9"),
            hover_color=("#2980b9", "#1f618d")
        )
        self.register_button.pack(fill=ctk.X, pady=(0, 20))
        
        # S√©parateur ou
        self._create_separator(form_frame)
        
        # Bouton d'authentification Google
        google_button = ctk.CTkButton(
            form_frame,
            text="S'inscrire avec Google",
            image=self._get_google_icon(),
            compound="left",
            command=self._handle_google_auth,
            height=40,
            corner_radius=8,
            fg_color=("#ffffff", "#333333"),
            text_color=("#333333", "#ffffff"),
            hover_color=("#eeeeee", "#444444"),
            border_width=1,
            border_color=("#dddddd", "#555555")
        )
        google_button.pack(fill=ctk.X, pady=(0, 10))
        
        # D√©j√† un compte ?
        login_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        login_frame.pack(fill=ctk.X, pady=(10, 0))
        
        ctk.CTkLabel(
            login_frame,
            text="D√©j√† un compte ?",
            font=ctk.CTkFont(size=13)
        ).pack(side=ctk.LEFT, padx=(5, 5))
        
        login_link = ctk.CTkButton(
            login_frame,
            text="Se connecter",
            font=ctk.CTkFont(size=13, underline=True),
            fg_color="transparent",
            hover_color="transparent",
            text_color=("#3498db", "#2980b9"),
            width=30,
            height=20,
            command=lambda: self._show_tab("login")
        )
        login_link.pack(side=ctk.LEFT)
    
    def _create_account_view(self):
        """Cr√©e la vue du compte utilisateur"""
        # Ne rien faire - la vue account est maintenant g√©r√©e ailleurs
        logger.info("Vue du compte utilisateur d√©sactiv√©e dans AuthView")
        pass
    
    def _handle_keyboard_nav(self, event):
        """
        G√®re la navigation au clavier pour am√©liorer l'accessibilit√©
        
        Args:
            event: √âv√©nement clavier
        """
        try:
            # R√©cup√©rer la touche press√©e
            key = event.keysym
            
            # G√©rer la touche Tab pour la navigation entre les champs
            if key == "Tab":
                # La navigation par d√©faut est g√©r√©e par Tkinter
                pass
                
            # G√©rer la touche Entr√©e pour soumettre le formulaire
            elif key == "Return":
                # D√©terminer l'onglet actif
                current_tab = self.current_tab.get()
                
                # Soumettre le formulaire correspondant
                if current_tab == "login":
                    self._handle_login()
                elif current_tab == "register":
                    self._handle_register()
                elif current_tab == "account":
                    self._save_profile()
                    
            # G√©rer les touches de navigation entre les onglets
            elif key == "1" and event.state & 4:  # Ctrl+1
                self._show_tab("login")
            elif key == "2" and event.state & 4:  # Ctrl+2
                self._show_tab("register")
            elif key == "3" and event.state & 4:  # Ctrl+3
                self._show_tab("account")
                
            # G√©rer la touche √âchap pour fermer la fen√™tre
            elif key == "Escape":
                self.hide()
        except Exception as e:
            logger.error(f"Erreur lors de la gestion de la navigation au clavier: {e}")

    def _check_login_attempts(self, email):
        """
        V√©rifie si l'utilisateur a d√©pass√© le nombre maximum de tentatives de connexion
        
        Args:
            email: Email de l'utilisateur
            
        Returns:
            bool: True si l'utilisateur peut tenter de se connecter, False sinon
        """
        try:
            # Si l'email n'est pas dans le dictionnaire des tentatives, autoriser
            if email not in self.login_attempts:
                return True
                
            # R√©cup√©rer les informations sur les tentatives
            timestamp, count = self.login_attempts[email]
            
            # V√©rifier si le d√©lai d'attente est √©coul√©
            elapsed = (datetime.now() - timestamp).total_seconds()
            if elapsed > self.LOGIN_TIMEOUT:
                # R√©initialiser les tentatives
                del self.login_attempts[email]
                return True
                
            # V√©rifier si le nombre maximum de tentatives est atteint
            if count >= self.MAX_LOGIN_ATTEMPTS:
                logger.warning(f"Nombre maximum de tentatives atteint pour {email}")
                return False
                
            # Autoriser la tentative
            return True
        except Exception as e:
            logger.error(f"Erreur lors de la v√©rification des tentatives de connexion: {e}")
            # En cas d'erreur, autoriser par d√©faut
            return True
        
    def _handle_logout(self):
        """G√®re la d√©connexion de l'utilisateur"""
        try:
            # V√©rifier si un utilisateur est connect√©
            if not self.current_user:
                logger.warning("Tentative de d√©connexion sans utilisateur connect√©")
                return
                
            # D√©connecter l'utilisateur
            email = self.current_user.get("email", "")
            success = self.usage_tracker.clear_current_user()
            
            if success:
                logger.info(f"Utilisateur d√©connect√©: {email}")
                
                # R√©initialiser l'utilisateur courant
                self.current_user = None
                
                # Mettre √† jour l'interface
                self._update_auth_state()
                
                # Appeler le callback d'authentification si d√©fini
                if hasattr(self, 'auth_callback') and self.auth_callback:
                    self.auth_callback(False, None)
                
                # Afficher l'onglet login
                self._show_tab("login")
                
                # Afficher un message de succ√®s
                if hasattr(self, 'login_status_label'):
                    self.login_status_label.configure(
                        text="D√©connexion r√©ussie",
                        text_color="green"
                    )
                    # Effacer le message apr√®s 3 secondes
                    self.window.after(3000, lambda: self.login_status_label.configure(text=""))
            else:
                logger.error(f"Erreur lors de la d√©connexion de {email}")
                
                # Afficher un message d'erreur
                if hasattr(self, 'login_status_label'):
                    self.login_status_label.configure(
                        text="Erreur lors de la d√©connexion",
                        text_color="red"
                    )
        except Exception as e:
            logger.error(f"Erreur lors de la d√©connexion: {e}")
            
            # Afficher un message d'erreur
            if hasattr(self, 'login_status_label'):
                self.login_status_label.configure(
                    text=f"Erreur: {str(e)}",
                    text_color="red"
                )
        
    def _get_google_icon(self):
        """R√©cup√®re l'ic√¥ne Google ou cr√©e une ic√¥ne temporaire"""
        try:
            icon_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "assets", "google_icon.png")
            if os.path.exists(icon_path):
                return ctk.CTkImage(Image.open(icon_path), size=(20, 20))
            else:
                # Cr√©er une ic√¥ne Google factice
                logger.info("Ic√¥ne Google non trouv√©e, cr√©ation d'une ic√¥ne factice")
                # Cr√©er une image avec un G blanc sur fond rouge
                img = Image.new("RGB", (20, 20), color=(234, 67, 53))  # Rouge Google
                return ctk.CTkImage(img, size=(20, 20))
        except Exception as e:
            logger.warning(f"Impossible de charger l'ic√¥ne Google: {e}")
            # Si une erreur se produit, retourner une image vide
            img = Image.new("RGB", (20, 20), color=(255, 255, 255))
            return ctk.CTkImage(img, size=(20, 20))

    def _show_tab(self, tab_name):
        """
        Affiche un onglet sp√©cifique
        
        Args:
            tab_name: Nom de l'onglet √† afficher (login, register, account)
        """
        try:
            logger.info(f"Demande d'affichage de l'onglet: {tab_name}")
            
            # Si l'onglet est "account", utiliser la vue AccountView directement
            if tab_name == "account":
                logger.info("Redirection vers la vue AccountView")
                self.hide()  # Masquer cette vue
                
                # Rediriger vers la vue account via MainView si possible
                try:
                    from views.main_view import get_main_view_instance
                    main_view = get_main_view_instance()
                    if main_view and hasattr(main_view, 'show_account'):
                        main_view.show_account()
                        return
                except Exception as e:
                    logger.error(f"Erreur lors de la redirection vers AccountView: {e}")
                
                # Sinon essayer d'utiliser le bouton d'authentification du dashboard
                try:
                    # Rechercher le bouton d'authentification dans la hi√©rarchie des widgets
                    root = self.window.winfo_toplevel()
                    for widget in root.winfo_children():
                        if hasattr(widget, "_show_user_account"):
                            widget._show_user_account()
                            return
                except Exception as e:
                    logger.error(f"Erreur lors de la recherche du bouton d'authentification: {e}")
                
                # Si √ßa √©choue, afficher un message
                self.hide()
                self.window.after(100, lambda: CTkMessagebox(
                    title="Acc√®s au compte",
                    message="Utilisez le bouton 'Mon compte' du tableau de bord pour acc√©der √† votre compte.",
                    icon="info"
                ))
                return
            
            # Pour les autres onglets, continuer normalement
            # Mettre √† jour la variable d'onglet actuel
            self.current_tab.set(tab_name)
            
            # Mettre en √©vidence l'onglet actuel
            if hasattr(self, 'login_tab'):
                self.login_tab.configure(fg_color="transparent" if tab_name != "login" else ("gray85", "gray25"))
            if hasattr(self, 'register_tab'):
                self.register_tab.configure(fg_color="transparent" if tab_name != "register" else ("gray85", "gray25"))
            if hasattr(self, 'account_tab'):
                self.account_tab.configure(fg_color="transparent" if tab_name != "account" else ("gray85", "gray25"))
            
            # Mettre √† jour l'affichage en fonction de l'onglet s√©lectionn√©
            self._update_tab_content()
            
            logger.debug(f"Onglet {tab_name} affich√© avec succ√®s")
        except Exception as e:
            logger.error(f"Erreur lors de l'affichage de l'onglet {tab_name}: {e}")
            # Tenter une approche alternative en cas d'erreur
            self._show_tab_alternative(tab_name)
    
    def _update_tab_content(self):
        """Met √† jour le contenu affich√© selon l'onglet s√©lectionn√©"""
        try:
            tab_name = self.current_tab.get()
            
            # Masquer tous les contenus d'onglets
            for content in ["login_frame", "register_frame", "account_frame"]:
                if hasattr(self, content) and getattr(self, content):
                    getattr(self, content).pack_forget()
            
            # Afficher le contenu appropri√©
            if tab_name == "login" and hasattr(self, 'login_frame'):
                self.login_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
            elif tab_name == "register" and hasattr(self, 'register_frame'):
                self.register_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
            elif tab_name == "account" and hasattr(self, 'account_frame'):
                self.account_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
            
            # Mettre √† jour les styles des onglets
            if hasattr(self, 'tabs') and self.tabs:
                for tab in self.tabs.winfo_children():
                    tab_id = tab.cget("text").lower()
                    if tab_id == tab_name:
                        tab.configure(fg_color=("gray85", "gray25"))
                    else:
                        tab.configure(fg_color="transparent")
                        
            logger.debug(f"Contenu de l'onglet {tab_name} affich√©")
        except Exception as e:
            logger.error(f"Erreur lors de la mise √† jour du contenu de l'onglet: {e}")
            # En cas d'erreur, on peut essayer une approche plus directe
            try:
                if tab_name == "login" and hasattr(self, 'login_frame'):
                    for content in ["register_frame", "account_frame"]:
                        if hasattr(self, content) and getattr(self, content):
                            getattr(self, content).pack_forget()
                    self.login_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
                elif tab_name == "register" and hasattr(self, 'register_frame'):
                    for content in ["login_frame", "account_frame"]:
                        if hasattr(self, content) and getattr(self, content):
                            getattr(self, content).pack_forget()
                    self.register_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
                elif tab_name == "account" and hasattr(self, 'account_frame'):
                    for content in ["login_frame", "register_frame"]:
                        if hasattr(self, content) and getattr(self, content):
                            getattr(self, content).pack_forget()
                    self.account_frame.pack(fill=ctk.BOTH, expand=True, padx=20, pady=20)
                    
                logger.debug(f"Contenu de l'onglet {tab_name} affich√© via m√©thode alternative")
            except Exception as e2:
                logger.error(f"√âchec critique lors de l'affichage alternatif de l'onglet: {e2}")
    
    def _load_user_data(self):
        """
        Charge les donn√©es de l'utilisateur actuellement connect√©
        et met √† jour l'interface en cons√©quence
        """
        try:
            # R√©cup√©rer les donn√©es utilisateur
            user_data = self.usage_tracker.get_user_data()
            
            if user_data and "email" in user_data:
                self.current_user = user_data
                logger.info(f"Utilisateur charg√©: {user_data.get('email')}")
                
                # Mettre √† jour les champs du profil
                if hasattr(self, 'user_name_label'):
                    name = user_data.get('name', 'Utilisateur')
                    self.user_name_label.configure(text=name)
                
                if hasattr(self, 'user_email_label'):
                    email = user_data.get('email', '')
                    self.user_email_label.configure(text=email)
                
                # Mettre √† jour les autres champs du profil si disponibles
                if hasattr(self, 'profile_name_var') and 'name' in user_data:
                    self.profile_name_var.set(user_data['name'])
                
                if hasattr(self, 'profile_email_var') and 'email' in user_data:
                    self.profile_email_var.set(user_data['email'])
                
                if hasattr(self, 'profile_created_var') and 'created_at' in user_data:
                    created_at = user_data.get('created_at', '')
                    if created_at:
                        try:
                            # Formater la date si c'est une cha√Æne ISO
                            date_obj = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                            formatted_date = date_obj.strftime('%d/%m/%Y %H:%M')
                            self.profile_created_var.set(formatted_date)
                        except:
                            self.profile_created_var.set(created_at)
                
                # Appeler le callback d'authentification si d√©fini
                if hasattr(self, 'auth_callback') and self.auth_callback:
                    self.auth_callback(True, user_data)
            else:
                self.current_user = None
                logger.info("Aucun utilisateur connect√©")
                
                # Appeler le callback d'authentification si d√©fini
                if hasattr(self, 'auth_callback') and self.auth_callback:
                    self.auth_callback(False, None)
        except Exception as e:
            logger.error(f"Erreur lors du chargement des donn√©es utilisateur: {e}")
            self.current_user = None
    
    def _update_auth_state(self):
        """
        Met √† jour l'interface en fonction de l'√©tat d'authentification
        """
        try:
            # V√©rifier si un utilisateur est connect√©
            is_logged_in = self.current_user is not None
            
            # Mettre √† jour la visibilit√© des onglets
            if is_logged_in:
                # Afficher l'onglet Compte et masquer l'onglet Inscription
                if hasattr(self, 'account_tab') and self.account_tab:
                    self.account_tab.grid()
                
                # Si on est sur l'onglet login ou register, basculer vers account
                current_tab = self.current_tab.get()
                if current_tab in ["login", "register"]:
                    self._show_tab("account")
            else:
                # Masquer l'onglet Compte si on n'est pas connect√©
                # et qu'on est sur cet onglet, basculer vers login
                current_tab = self.current_tab.get()
                if current_tab == "account":
                    self._show_tab("login")
            
            # Mettre √† jour les boutons de connexion/d√©connexion
            if hasattr(self, 'login_button') and hasattr(self, 'logout_button'):
                if self.login_button and self.logout_button:
                    if is_logged_in:
                        if self.login_button and self.login_button.winfo_exists():
                            self.login_button.pack_forget()
                        if self.logout_button and self.logout_button.winfo_exists():
                            self.logout_button.pack(fill=ctk.X, pady=(10, 0))
                    else:
                        if self.logout_button and self.logout_button.winfo_exists():
                            self.logout_button.pack_forget()
                        if self.login_button and self.login_button.winfo_exists():
                            self.login_button.pack(fill=ctk.X, pady=(10, 0))
        except Exception as e:
            logger.error(f"Erreur lors de la mise √† jour de l'√©tat d'authentification: {e}")
            
    def _save_user_settings(self, user_data: Dict[str, Any]) -> bool:
        """
        Sauvegarde les param√®tres de l'utilisateur
        
        Args:
            user_data: Donn√©es utilisateur √† sauvegarder
            
        Returns:
            bool: True si la sauvegarde a r√©ussi, False sinon
        """
        try:
            if not user_data or "email" not in user_data:
                logger.error("Donn√©es utilisateur invalides")
                return False
                
            # R√©cup√©rer les utilisateurs existants
            users_file = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "users.json")
            users = {}
            
            if os.path.exists(users_file):
                try:
                    with open(users_file, 'r', encoding='utf-8') as f:
                        users = json.load(f)
                except Exception as e:
                    logger.error(f"Erreur lors de la lecture des utilisateurs: {e}")
            
            # Mettre √† jour les donn√©es de l'utilisateur
            email = user_data.get("email")
            
            # Supprimer l'email des donn√©es pour √©viter la duplication
            user_data_copy = user_data.copy()
            if "email" in user_data_copy:
                del user_data_copy["email"]
                
            # Mettre √† jour les donn√©es
            users[email] = user_data_copy
            
            # Sauvegarder les utilisateurs
            os.makedirs(os.path.dirname(users_file), exist_ok=True)
            with open(users_file, 'w', encoding='utf-8') as f:
                json.dump(users, f, indent=2, ensure_ascii=False)
                
            logger.info(f"Param√®tres utilisateur sauvegard√©s pour {email}")
            return True
        except Exception as e:
            logger.error(f"Erreur lors de la sauvegarde des param√®tres utilisateur: {e}")
            return False
            
    def _save_profile(self):
        """Sauvegarde les modifications du profil utilisateur"""
        try:
            if not self.current_user:
                logger.error("Aucun utilisateur connect√©")
                return
                
            # R√©cup√©rer les valeurs des champs
            name = self.profile_name_var.get() if hasattr(self, 'profile_name_var') else ""
            
            # Mettre √† jour les donn√©es utilisateur
            user_data = self.current_user.copy()
            user_data["name"] = name
            
            # Sauvegarder les modifications
            if self._save_user_settings(user_data):
                # Mettre √† jour l'utilisateur courant
                self.current_user = user_data
                
                # Mettre √† jour l'interface
                if hasattr(self, 'user_name_label'):
                    self.user_name_label.configure(text=name)
                    
                # Afficher un message de succ√®s
                logger.info("Profil mis √† jour avec succ√®s")
                
                # Afficher un message dans l'interface
                if hasattr(self, 'profile_status_label'):
                    self.profile_status_label.configure(
                        text="Profil mis √† jour avec succ√®s",
                        text_color="green"
                    )
                    # Effacer le message apr√®s 3 secondes
                    self.window.after(3000, lambda: self.profile_status_label.configure(text=""))
            else:
                # Afficher un message d'erreur
                logger.error("Erreur lors de la mise √† jour du profil")
                
                # Afficher un message dans l'interface
                if hasattr(self, 'profile_status_label'):
                    self.profile_status_label.configure(
                        text="Erreur lors de la mise √† jour du profil",
                        text_color="red"
                    )
        except Exception as e:
            logger.error(f"Erreur lors de la sauvegarde du profil: {e}")
            
            # Afficher un message dans l'interface
            if hasattr(self, 'profile_status_label'):
                self.profile_status_label.configure(
                    text=f"Erreur: {str(e)}",
                    text_color="red"
                )
                
    def _handle_login(self):
        """G√®re la connexion de l'utilisateur"""
        try:
            # R√©cup√©rer les valeurs des champs
            email = self.email_var.get()
            password = self.password_var.get()
            remember_me = self.remember_var.get() if hasattr(self, 'remember_var') else False
            
            # V√©rifier que les champs sont remplis
            if not email or not password:
                logger.warning("Champs de connexion incomplets")
                if hasattr(self, 'login_status_label'):
                    self.login_status_label.configure(
                        text="Veuillez remplir tous les champs",
                        text_color="red"
                    )
                return
            
            # V√©rifier le format de l'email
            if not self._is_valid_email(email):
                logger.warning("Format d'email invalide")
                if hasattr(self, 'login_status_label'):
                    self.login_status_label.configure(
                        text="Format d'email invalide",
                        text_color="red"
                    )
                return
            
            # V√©rifier les tentatives de connexion
            if not self._check_login_attempts(email):
                logger.warning(f"Trop de tentatives de connexion pour {email}")
                if hasattr(self, 'login_status_label'):
                    self.login_status_label.configure(
                        text=f"Trop de tentatives, r√©essayez dans {self.LOGIN_TIMEOUT//60} minutes",
                        text_color="red"
                    )
                return
            
            # V√©rifier les identifiants
            hashed_password = hashlib.sha256(password.encode()).hexdigest()
            user_data = self.usage_tracker.authenticate_user(email, hashed_password)
            
            if user_data:
                logger.info(f"Utilisateur connect√©: {email} (Rester connect√©: {remember_me})")
                
                # Mettre √† jour l'utilisateur courant
                self.current_user = user_data
                
                # Enregistrer la pr√©f√©rence "Rester connect√©"
                self.usage_tracker.set_remember_me(email, remember_me)
                logger.info(f"Pr√©f√©rence 'Rester connect√©' d√©finie √† {remember_me} pour {email}")
                
                # R√©initialiser les tentatives de connexion
                if email in self.login_attempts:
                    del self.login_attempts[email]
                
                # Mettre √† jour l'interface
                self._update_auth_state()
                
                # Masquer la fen√™tre d'authentification
                self.hide()
                
                # Appeler le callback d'authentification si d√©fini
                if hasattr(self, 'auth_callback') and self.auth_callback:
                    self.auth_callback(True, user_data)
                
                # Restaurer compl√®tement l'interface principale
                if hasattr(self.parent, 'main_frame') and self.parent.main_frame:
                    # S'assurer que tous les widgets sont visibles et correctement positionn√©s
                    try:
                        if not self.parent.main_frame.winfo_ismapped():
                            self.parent.main_frame.pack(fill="both", expand=True)
                            logger.info("Interface principale restaur√©e apr√®s connexion")
                    except Exception as e:
                        logger.error(f"Erreur lors de la restauration de l'interface principale: {e}")
                
                # S'assurer que le tableau de bord est affich√©
                if hasattr(self.parent, 'show_dashboard'):
                    try:
                        self.parent.show_dashboard()
                        logger.info("Tableau de bord affich√© apr√®s connexion")
                    except Exception as e:
                        logger.error(f"Erreur lors de l'affichage du tableau de bord: {e}")
                
                # Charger les param√®tres utilisateur
                self._load_user_data()
                
                return True
            else:
                logger.warning(f"√âchec de connexion pour {email}")
                
                # Incr√©menter les tentatives de connexion
                if email in self.login_attempts:
                    self.login_attempts[email][1] += 1
                else:
                    self.login_attempts[email] = [datetime.now(), 1]
                
                # Afficher un message d'erreur
                if hasattr(self, 'login_status_label'):
                    self.login_status_label.configure(
                        text="Email ou mot de passe incorrect",
                        text_color="red"
                    )
                
                return False
        except Exception as e:
            logger.error(f"Erreur lors de la connexion: {e}")
            
            # Afficher un message d'erreur
            if hasattr(self, 'login_status_label'):
                self.login_status_label.configure(
                    text=f"Erreur: {str(e)}",
                    text_color="red"
                )
            
            return False
            
    def _is_valid_email(self, email):
        """V√©rifie si l'email est valide"""
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
        
    def _handle_register(self):
        """G√®re l'inscription d'un nouvel utilisateur"""
        try:
            # R√©cup√©rer les valeurs des champs
            name = self.register_name_var.get() if hasattr(self, 'register_name_var') else ""
            email = self.email_var.get()
            password = self.password_var.get()
            confirm_password = self.confirm_password_var.get()
            
            # V√©rifier que les champs sont remplis
            if not email or not password or not confirm_password:
                logger.warning("Champs d'inscription incomplets")
                if hasattr(self, 'register_status_label'):
                    self.register_status_label.configure(
                        text="Veuillez remplir tous les champs obligatoires",
                        text_color="red"
                    )
                return False
            
            # V√©rifier le format de l'email
            if not self._is_valid_email(email):
                logger.warning("Format d'email invalide")
                if hasattr(self, 'register_status_label'):
                    self.register_status_label.configure(
                        text="Format d'email invalide",
                        text_color="red"
                    )
                return False
            
            # V√©rifier que les mots de passe correspondent
            if password != confirm_password:
                logger.warning("Les mots de passe ne correspondent pas")
                if hasattr(self, 'register_status_label'):
                    self.register_status_label.configure(
                        text="Les mots de passe ne correspondent pas",
                        text_color="red"
                    )
                return False
            
            # V√©rifier la complexit√© du mot de passe
            if len(password) < self.PASSWORD_MIN_LENGTH:
                logger.warning("Mot de passe trop court")
                if hasattr(self, 'register_status_label'):
                    self.register_status_label.configure(
                        text=f"Le mot de passe doit contenir au moins {self.PASSWORD_MIN_LENGTH} caract√®res",
                        text_color="red"
                    )
                return False
            
            # V√©rifier si l'utilisateur existe d√©j√†
            users_file = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "users.json")
            users = {}
            
            if os.path.exists(users_file):
                try:
                    with open(users_file, 'r', encoding='utf-8') as f:
                        users = json.load(f)
                        
                    if email in users:
                        logger.warning(f"L'utilisateur {email} existe d√©j√†")
                        if hasattr(self, 'register_status_label'):
                            self.register_status_label.configure(
                                text="Cet email est d√©j√† utilis√©",
                                text_color="red"
                            )
                        return False
                except Exception as e:
                    logger.error(f"Erreur lors de la lecture des utilisateurs: {e}")
            
            # Cr√©er le nouvel utilisateur
            hashed_password = hashlib.sha256(password.encode()).hexdigest()
            user_data = {
                "email": email,
                "password": hashed_password,
                "name": name,
                "created_at": datetime.now().isoformat(),
                "last_login": datetime.now().isoformat(),
                "settings": {}
            }
            
            # Sauvegarder l'utilisateur
            users[email] = {k: v for k, v in user_data.items() if k != "email"}
            
            os.makedirs(os.path.dirname(users_file), exist_ok=True)
            with open(users_file, 'w', encoding='utf-8') as f:
                json.dump(users, f, indent=2, ensure_ascii=False)
            
            logger.info(f"Nouvel utilisateur cr√©√©: {email}")
            
            # Connecter l'utilisateur
            self.current_user = user_data
            self.usage_tracker.set_current_user(user_data)
            
            # Mettre √† jour l'interface
            self._update_auth_state()
            
            # Afficher un message de succ√®s temporaire
            if hasattr(self, 'register_status_label'):
                self.register_status_label.configure(
                    text="Inscription r√©ussie ! Redirection vers le tableau de bord...",
                    text_color="green"
                )
            
            # Cr√©er un spinner de chargement pendant la redirection
            loading_frame = None
            try:
                loading_frame = ctk.CTkFrame(self.window)
                loading_frame.place(relx=0.5, rely=0.5, anchor=ctk.CENTER)
                
                # Titre du chargement
                ctk.CTkLabel(
                    loading_frame,
                    text="Pr√©paration du tableau de bord",
                    font=ctk.CTkFont(size=16, weight="bold")
                ).pack(pady=(10, 5))
                
                # Message
                ctk.CTkLabel(
                    loading_frame,
                    text="Veuillez patienter pendant l'initialisation de votre tableau de bord..."
                ).pack(pady=5)
                
                # Spinner
                spinner = ctk.CTkProgressBar(loading_frame, width=200)
                spinner.pack(pady=10)
                spinner.configure(mode="indeterminate")
                spinner.start()
                
                # Forcer la mise √† jour de l'interface
                self.window.update()
            except Exception as e:
                logger.error(f"Erreur lors de la cr√©ation du spinner: {e}")
            
            # Appeler le callback d'authentification si d√©fini apr√®s un court d√©lai
            def complete_registration():
                try:
                    # Appeler le callback d'authentification si d√©fini
                    if hasattr(self, 'auth_callback') and self.auth_callback:
                        self.auth_callback(True, user_data)
                    
                    # Fermer la fen√™tre d'authentification
                    self.hide()
                    
                    # Afficher un message de succ√®s et rediriger vers le tableau de bord
                    if hasattr(self.parent, 'show_dashboard') and callable(self.parent.show_dashboard):
                        # Rediriger vers le tableau de bord
                        self.parent.show_dashboard()
                        logger.info("Utilisateur redirig√© vers le tableau de bord apr√®s inscription")
                    else:
                        logger.warning("Impossible de rediriger vers le tableau de bord: m√©thode non trouv√©e")
                        # Tentative alternative pour afficher le tableau de bord
                        try:
                            if hasattr(self.parent, 'show_view') and callable(self.parent.show_view):
                                self.parent.show_view("dashboard")
                                logger.info("Redirection alternative vers le tableau de bord")
                            elif hasattr(self.parent, 'winfo_toplevel') and hasattr(self.parent.winfo_toplevel(), 'show_view'):
                                # Si nous sommes dans une fen√™tre modale, essayer avec la fen√™tre principale
                                self.parent.winfo_toplevel().show_view("dashboard")
                                logger.info("Redirection via la fen√™tre principale vers le tableau de bord")
                        except Exception as e:
                            logger.error(f"Erreur lors de la redirection vers le tableau de bord: {e}")
                    
                    # Afficher un message de bienvenue
                    if hasattr(self.parent, 'show_message'):
                        self.parent.show_message(
                            "Inscription r√©ussie",
                            f"Bienvenue {name if name else email} ! Votre compte a √©t√© cr√©√© avec succ√®s.",
                            "success"
                        )
                except Exception as e:
                    logger.error(f"Erreur lors de la finalisation de l'inscription: {e}")
                    if loading_frame and loading_frame.winfo_exists():
                        loading_frame.destroy()
            
            # D√©clencher la redirection apr√®s un court d√©lai pour permettre l'affichage du spinner
            self.window.after(500, complete_registration)
            
            return True
        except Exception as e:
            logger.error(f"Erreur lors de l'inscription: {e}")
            
            # Afficher un message d'erreur
            if hasattr(self, 'register_status_label'):
                self.register_status_label.configure(
                    text=f"Erreur: {str(e)}",
                    text_color="red"
                )
            
            return False
            
    def _validate_email(self, *args):
        """Valide le format de l'email en temps r√©el"""
        try:
            email = self.email_var.get()
            
            # V√©rifier si l'email est vide
            if not email:
                self.email_valid = False
                
                # Mettre √† jour les messages d'erreur
                if hasattr(self, 'login_email_error'):
                    self.login_email_error.configure(text="")
                if hasattr(self, 'register_email_error'):
                    self.register_email_error.configure(text="")
                    
                return
            
            # V√©rifier le format de l'email
            is_valid = self._is_valid_email(email)
            self.email_valid = is_valid
            
            # Mettre √† jour les messages d'erreur
            error_msg = "" if is_valid else "Format d'email invalide"
            
            if hasattr(self, 'login_email_error'):
                self.login_email_error.configure(text=error_msg)
                
            if hasattr(self, 'register_email_error'):
                self.register_email_error.configure(text=error_msg)
        except Exception as e:
            logger.error(f"Erreur lors de la validation de l'email: {e}")
            
    def _validate_password(self, *args):
        """Valide la complexit√© du mot de passe en temps r√©el"""
        try:
            password = self.password_var.get()
            
            # V√©rifier si le mot de passe est vide
            if not password:
                self.password_valid = False
                
                # Mettre √† jour les messages d'erreur
                if hasattr(self, 'login_password_error'):
                    self.login_password_error.configure(text="")
                if hasattr(self, 'register_password_error'):
                    self.register_password_error.configure(text="")
                    
                return
            
            # V√©rifier la longueur du mot de passe
            is_valid = len(password) >= self.PASSWORD_MIN_LENGTH
            self.password_valid = is_valid
            
            # Mettre √† jour les messages d'erreur
            error_msg = "" if is_valid else f"Minimum {self.PASSWORD_MIN_LENGTH} caract√®res"
            
            if hasattr(self, 'login_password_error'):
                self.login_password_error.configure(text=error_msg)
                
            if hasattr(self, 'register_password_error'):
                self.register_password_error.configure(text=error_msg)
                
            # Valider √©galement la confirmation si elle existe
            if hasattr(self, 'confirm_password_var'):
                self._validate_confirm_password()
        except Exception as e:
            logger.error(f"Erreur lors de la validation du mot de passe: {e}")
            
    def _validate_confirm_password(self, *args):
        """Valide que la confirmation du mot de passe correspond au mot de passe"""
        try:
            password = self.password_var.get()
            confirm_password = self.confirm_password_var.get()
            
            # V√©rifier si la confirmation est vide
            if not confirm_password:
                self.confirm_password_valid = False
                
                # Mettre √† jour le message d'erreur
                if hasattr(self, 'register_confirm_password_error'):
                    self.register_confirm_password_error.configure(text="")
                    
                return
            
            # V√©rifier que les mots de passe correspondent
            is_valid = password == confirm_password
            self.confirm_password_valid = is_valid
            
            # Mettre √† jour le message d'erreur
            error_msg = "" if is_valid else "Les mots de passe ne correspondent pas"
            
            if hasattr(self, 'register_confirm_password_error'):
                self.register_confirm_password_error.configure(text=error_msg)
        except Exception as e:
            logger.error(f"Erreur lors de la validation de la confirmation du mot de passe: {e}")

    def hide(self):
        """Masque la fen√™tre d'authentification"""
        try:
            # Si nous utilisons une fen√™tre Toplevel, la masquer
            if hasattr(self, 'window') and self.window.winfo_exists():
                self.window.withdraw()
                logger.info("Fen√™tre d'authentification masqu√©e")
            # Si nous utilisons le parent directement, masquer les widgets
            elif hasattr(self, 'main_frame'):
                self.main_frame.pack_forget()
                logger.info("Widgets d'authentification masqu√©s")
        except Exception as e:
            logger.error(f"Erreur lors du masquage de l'interface d'authentification: {e}")
            
    def show(self):
        """Affiche la fen√™tre d'authentification"""
        try:
            # D√©truire toute fen√™tre TopLevel existante pour √©viter les doublons
            if hasattr(self, 'window') and self.window.winfo_exists():
                try:
                    self.window.destroy()
                except Exception as e:
                    logger.debug(f"Erreur lors de la destruction de la fen√™tre existante: {e}")
            
            # Cr√©er une interface directement dans le parent
            if not hasattr(self, 'main_frame') or not self.main_frame:
                # Cr√©er les widgets directement dans le parent
                self._create_widgets()
                logger.info("Widgets d'authentification cr√©√©s directement dans le parent")
            
            # Mettre √† jour l'interface selon l'√©tat de connexion
            self._update_auth_state()
            
            # S'assurer que le contenu est visible
            if hasattr(self, 'main_frame'):
                self.main_frame.pack(fill="both", expand=True, padx=20, pady=20)
            
            # Forcer la mise √† jour pour √©viter les probl√®mes d'affichage
            self.parent.update_idletasks()
            
            logger.info("Interface d'authentification affich√©e directement dans le parent")
            
        except Exception as e:
            logger.error(f"Erreur lors de l'affichage de l'interface d'authentification: {e}")
            # Cr√©er une interface de secours en cas d'erreur
            try:
                # Nettoyer l'interface existante
                for widget in self.parent.winfo_children():
                    widget.destroy()
                
                # Cr√©er une interface minimaliste
                frame = ctk.CTkFrame(self.parent)
                frame.pack(fill="both", expand=True, padx=20, pady=20)
                
                label = ctk.CTkLabel(
                    frame,
                    text="Interface d'authentification",
                    font=ctk.CTkFont(size=16, weight="bold")
                )
                label.pack(pady=20)
                
                # Champs d'authentification simples
                email_label = ctk.CTkLabel(frame, text="Email:")
                email_label.pack(anchor="w", pady=(10, 0))
                
                self.email_var = ctk.StringVar()
                email_entry = ctk.CTkEntry(frame, width=300, textvariable=self.email_var)
                email_entry.pack(pady=(0, 10))
                
                password_label = ctk.CTkLabel(frame, text="Mot de passe:")
                password_label.pack(anchor="w", pady=(10, 0))
                
                self.password_var = ctk.StringVar()
                password_entry = ctk.CTkEntry(frame, show="‚Ä¢", width=300, textvariable=self.password_var)
                password_entry.pack(pady=(0, 20))
                
                login_button = ctk.CTkButton(
                    frame,
                    text="Se connecter",
                    width=200,
                    command=self._handle_login
                )
                login_button.pack(pady=10)
                
                logger.info("Interface d'authentification simplifi√©e cr√©√©e apr√®s erreur")
            except Exception as e2:
                logger.critical(f"√âchec critique lors de la cr√©ation d'une interface de secours: {e2}")
                # Afficher un simple message d'erreur
                try:
                    label = ctk.CTkLabel(
                        self.parent,
                        text="Erreur lors de l'affichage de l'interface d'authentification.\nVeuillez red√©marrer l'application.",
                        font=ctk.CTkFont(size=14),
                        text_color="red"
                    )
                    label.pack(expand=True, pady=50)
                except:
                    pass

    def set_auth_callback(self, callback):
        """
        D√©finit le callback √† appeler lorsque l'√©tat d'authentification change
        
        Args:
            callback: Fonction √† appeler avec (is_authenticated, user_data)
        """
        self.auth_callback = callback
        logger.info("Callback d'authentification d√©fini")

    def _show_tab_alternative(self, tab_name):
        """
        M√©thode alternative pour afficher un onglet lorsque l'approche principale √©choue
        
        Args:
            tab_name: Nom de l'onglet √† afficher (login, register, account)
        """
        try:
            # Mettre √† jour la variable d'onglet actuel
            self.current_tab.set(tab_name)
            
            # Si les frames d'onglets n'existent pas, essayer de les cr√©er
            try:
                if tab_name == "login" and (not hasattr(self, 'login_frame') or not self.login_frame):
                    self._create_login_tab()
                elif tab_name == "register" and (not hasattr(self, 'register_frame') or not self.register_frame):
                    self._create_register_tab()
                elif tab_name == "account" and (not hasattr(self, 'account_frame') or not self.account_frame):
                    self._create_account_tab()
            except Exception as e:
                logger.error(f"Erreur lors de la cr√©ation de l'onglet {tab_name}: {e}")
                # Continuer malgr√© l'erreur
            
            # V√©rifier si les frames d'onglets existent maintenant
            tab_frames = {
                "login": getattr(self, 'login_frame', None),
                "register": getattr(self, 'register_frame', None),
                "account": getattr(self, 'account_frame', None)
            }
            
            # Vider le content_frame si disponible
            if hasattr(self, 'content_frame') and self.content_frame:
                for widget in self.content_frame.winfo_children():
                    try:
                        widget.pack_forget()
                    except Exception:
                        pass
            else:
                # Si content_frame n'existe pas, recr√©er l'UI
                self._create_widgets()
                logger.info("Interface recr√©√©e car content_frame n'existe pas")
                # R√©essayer apr√®s la recr√©ation
                self._show_tab(tab_name)
                return
            
            # Si l'onglet demand√© existe maintenant, l'afficher
            if tab_frames[tab_name]:
                try:
                    self.content_frame.update_idletasks()  # Force une mise √† jour des widgets
                    tab_frames[tab_name].pack(fill=ctk.BOTH, expand=True, pady=(15, 0))
                    logger.info(f"Onglet {tab_name} affich√© (m√©thode alternative)")
                except Exception as e:
                    logger.error(f"Erreur lors de l'affichage de l'onglet {tab_name}: {e}")
                    # Continuer malgr√© l'erreur
            
            # Dans tous les cas, afficher un message simple si n√©cessaire
            if not (tab_frames[tab_name] and tab_frames[tab_name].winfo_ismapped()):
                try:
                    # Cr√©er un frame d'erreur simple
                    error_frame = ctk.CTkFrame(self.content_frame)
                    error_frame.pack(fill=ctk.BOTH, expand=True, pady=(15, 0))
                    
                    ctk.CTkLabel(
                        error_frame,
                        text=f"Bienvenue sur Vynal Docs Automator",
                        font=ctk.CTkFont(size=18, weight="bold")
                    ).pack(pady=(20, 10))
                    
                    if tab_name == "account":
                        message = "Gestion de votre compte utilisateur"
                    elif tab_name == "register":
                        message = "Cr√©ez un compte pour commencer"
                    else:
                        message = "Connectez-vous pour continuer"
                        
                    ctk.CTkLabel(
                        error_frame,
                        text=message
                    ).pack(pady=10)
                    
                    logger.info(f"Vue simplifi√©e affich√©e pour {tab_name}")
                except Exception as e:
                    logger.error(f"Erreur lors de l'affichage du message alternatif: {e}")
        except Exception as e:
            logger.error(f"Erreur lors de l'affichage alternatif de l'onglet {tab_name}: {e}")
            # En dernier recours, essayer de recr√©er compl√®tement l'interface
            if hasattr(self, '_create_widgets'):
                try:
                    self._create_widgets()
                    logger.info("Interface recr√©√©e apr√®s erreur d'affichage d'onglet")
                except Exception as e2:
                    logger.error(f"√âchec critique lors de la recr√©ation de l'interface: {e2}")

    def _create_account_tab(self):
        """Cr√©e le contenu de l'onglet compte"""
        try:
            if not hasattr(self, 'content_frame') or not self.content_frame:
                logger.error("content_frame n'existe pas, impossible de cr√©er l'onglet compte")
                return

            # Cr√©er le frame pour l'onglet compte s'il n'existe pas
            if not hasattr(self, 'account_frame') or not self.account_frame:
                self.account_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
            
            # Options de style
            title_font = ctk.CTkFont(size=18, weight="bold")
            section_font = ctk.CTkFont(size=14, weight="bold")
            
            # Titre
            title_frame = ctk.CTkFrame(self.account_frame, fg_color="transparent")
            title_frame.pack(fill=ctk.X, pady=(0, 15))
            
            ctk.CTkLabel(
                title_frame, 
                text="Mon Compte", 
                font=title_font
            ).pack(anchor=ctk.W)
            
            # Informations utilisateur
            if hasattr(self, 'current_user') and self.current_user:
                # Frame d'informations
                info_frame = ctk.CTkFrame(self.account_frame)
                info_frame.pack(fill=ctk.X, pady=10)
                
                # Email et nom
                user_details = ctk.CTkFrame(info_frame, fg_color="transparent")
                user_details.pack(fill=ctk.X, padx=15, pady=15)
                
                ctk.CTkLabel(
                    user_details,
                    text="Informations personnelles",
                    font=section_font
                ).pack(anchor=ctk.W, pady=(0, 10))
                
                # Email
                email_frame = ctk.CTkFrame(user_details, fg_color="transparent")
                email_frame.pack(fill=ctk.X, pady=5)
                
                ctk.CTkLabel(
                    email_frame,
                    text="Email:",
                    width=100,
                    anchor="w"
                ).pack(side=ctk.LEFT)
                
                ctk.CTkLabel(
                    email_frame,
                    text=self.current_user.get('email', 'Non d√©fini'),
                    anchor="w"
                ).pack(side=ctk.LEFT, fill=ctk.X, expand=True)
                
                # Nom (si disponible)
                if 'name' in self.current_user:
                    name_frame = ctk.CTkFrame(user_details, fg_color="transparent")
                    name_frame.pack(fill=ctk.X, pady=5)
                    
                    ctk.CTkLabel(
                        name_frame,
                        text="Nom:",
                        width=100,
                        anchor="w"
                    ).pack(side=ctk.LEFT)
                    
                    ctk.CTkLabel(
                        name_frame,
                        text=self.current_user.get('name', 'Non d√©fini'),
                        anchor="w"
                    ).pack(side=ctk.LEFT, fill=ctk.X, expand=True)
                
                # Licence (si disponible)
                if 'license_valid' in self.current_user:
                    is_valid = self.current_user.get('license_valid', False)
                    
                    license_frame = ctk.CTkFrame(self.account_frame)
                    license_frame.pack(fill=ctk.X, pady=10)
                    
                    license_title = ctk.CTkFrame(license_frame, fg_color="transparent")
                    license_title.pack(fill=ctk.X, padx=15, pady=(15, 10))
                    
                    ctk.CTkLabel(
                        license_title,
                        text="Licence",
                        font=section_font
                    ).pack(anchor=ctk.W)
                    
                    status_frame = ctk.CTkFrame(license_frame, fg_color="transparent")
                    status_frame.pack(fill=ctk.X, padx=15, pady=5)
                    
                    status_text = "Active" if is_valid else "Inactive"
                    status_color = "#4CAF50" if is_valid else "#F44336"
                    
                    ctk.CTkLabel(
                        status_frame,
                        text="Statut:",
                        width=100,
                        anchor="w"
                    ).pack(side=ctk.LEFT)
                    
                    ctk.CTkLabel(
                        status_frame,
                        text=status_text,
                        text_color=status_color,
                        anchor="w"
                    ).pack(side=ctk.LEFT, fill=ctk.X, expand=True)
            else:
                # Message si aucun utilisateur n'est connect√©
                ctk.CTkLabel(
                    self.account_frame,
                    text="Aucun utilisateur connect√©",
                    font=section_font
                ).pack(pady=20)
            
            # Boutons d'action
            buttons_frame = ctk.CTkFrame(self.account_frame, fg_color="transparent")
            buttons_frame.pack(fill=ctk.X, pady=(20, 10))
            
            # Bouton de d√©connexion
            logout_button = ctk.CTkButton(
                buttons_frame,
                text="D√©connexion",
                command=self._handle_logout,
                fg_color="#E74C3C",
                hover_color="#C0392B"
            )
            logout_button.pack(pady=5)
            
            # Bouton pour fermer la fen√™tre
            close_button = ctk.CTkButton(
                buttons_frame,
                text="Fermer",
                command=self.hide
            )
            close_button.pack(pady=5)
            
            logger.info("Onglet compte cr√©√© avec succ√®s")
            
        except Exception as e:
            logger.error(f"Erreur lors de la cr√©ation de l'onglet compte: {e}")